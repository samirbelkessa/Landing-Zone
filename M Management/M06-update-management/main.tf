# ==============================================================================
# M06 - Update Management (Azure Update Manager)
# ==============================================================================
# Purpose: Deploy Azure Update Manager Maintenance Configurations for automated patching
# Dependencies: F02 (naming), F03 (tags)
# Optional: M01 (Log Analytics), M03 (Action Groups), M04 (Alerts)
# ==============================================================================

#-------------------------------------------------------------------------------
# Maintenance Configurations
#-------------------------------------------------------------------------------

resource "azurerm_maintenance_configuration" "this" {
  for_each = local.all_configurations

  # Name generated by F02 (or custom prefix)
  name = local.configuration_names[each.key]

  resource_group_name = var.resource_group_name
  location            = var.location

  scope                    = each.value.scope
  visibility               = try(each.value.visibility, "Custom")
  in_guest_user_patch_mode = try(each.value.in_guest_user_patch_mode, "User")

  # Maintenance window
  window {
    start_date_time      = each.value.window.start_date_time
    duration             = each.value.window.duration
    time_zone            = each.value.window.time_zone
    recur_every          = each.value.window.recur_every
    expiration_date_time = try(each.value.window.expiration_date_time, null)
  }

  # Install patches configuration (only for InGuestPatch scope)
  dynamic "install_patches" {
    for_each = each.value.scope == "InGuestPatch" && each.value.install_patches != null ? [each.value.install_patches] : []

    content {
      reboot = try(install_patches.value.reboot, "IfRequired")

      # Linux configuration
      dynamic "linux" {
        for_each = try(install_patches.value.linux, null) != null ? [install_patches.value.linux] : []

        content {
          classifications_to_include  = try(linux.value.classifications_to_include, ["Critical", "Security"])
          package_names_mask_to_exclude = try(linux.value.package_names_mask_to_exclude, null)
          package_names_mask_to_include = try(linux.value.package_names_mask_to_include, null)
        }
      }

      # Windows configuration
      dynamic "windows" {
        for_each = try(install_patches.value.windows, null) != null ? [install_patches.value.windows] : []

        content {
          classifications_to_include = try(windows.value.classifications_to_include, ["Critical", "Security"])
          kb_numbers_to_exclude       = try(windows.value.kb_numbers_to_exclude, null)
          kb_numbers_to_include       = try(windows.value.kb_numbers_to_include, null)
        }
      }
    }
  }

  # Tags from F03 + additional tags
  tags = local.merged_tags

  lifecycle {
    ignore_changes = [
      tags["CreationDate"]
    ]
  }
}

#-------------------------------------------------------------------------------
# Maintenance Assignment - Virtual Machines (Static Assignment)
#-------------------------------------------------------------------------------

resource "azurerm_maintenance_assignment_virtual_machine" "this" {
  for_each = {
    for assignment_key, assignment in var.vm_assignments :
    assignment_key => {
      config_key = assignment.maintenance_configuration_key
      vm_ids     = assignment.virtual_machine_ids
    }
  }

  location = var.location

  # Use the full generated name from F02
  maintenance_configuration_id = azurerm_maintenance_configuration.this[each.value.config_key].id

  # Azure requires one assignment per VM, so we take the first VM
  # For multiple VMs, create multiple entries in var.vm_assignments
  virtual_machine_id = each.value.vm_ids[0]

  depends_on = [azurerm_maintenance_configuration.this]
}

#-------------------------------------------------------------------------------
# Maintenance Assignment - Dynamic Scope (Filter-based Assignment)
#-------------------------------------------------------------------------------
# NOTE: Tag filters are configured MANUALLY in Azure Portal after deployment
# Terraform lifecycle.ignore_changes protects manual configurations
#-------------------------------------------------------------------------------

resource "azurerm_maintenance_assignment_dynamic_scope" "this" {
  for_each = var.dynamic_scope_assignments

  # Assignment name with F02 prefix for consistency
  name = "${local.name_prefix}-assignment-${each.key}"

  # Use the full generated name from F02
  maintenance_configuration_id = azurerm_maintenance_configuration.this[each.value.maintenance_configuration_key].id

  filter {
    resource_types  = try(each.value.filter.resource_types, ["Microsoft.Compute/virtualMachines", "Microsoft.HybridCompute/machines"])
    resource_groups = try(each.value.filter.resource_groups, null)
    locations       = try(each.value.filter.locations, local.default_locations)
    os_types        = try(each.value.filter.os_types, null)
    
    # Tag filters are NOT supported in Terraform due to technical limitations
    # Configure tag filters manually in Azure Portal after deployment:
    # Azure Portal → Update Manager → Schedules → [Config] → Machines → Dynamic scopes → Edit
  }

  # CRITICAL: Prevents Terraform from overwriting manual tag filter configurations
  lifecycle {
    ignore_changes = [filter]
  }

  depends_on = [azurerm_maintenance_configuration.this]
}
